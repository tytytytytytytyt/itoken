server:
  port: 7001

spring:
  application:
    name: itoken-eureka
  boot:
    admin:
      client:
        url: http://localhost:9412
  zipkin:
    base-url: http://localhost:9411



eureka:
  eureka:
    server:
      # 关闭自我保护
      enable-self-preservation: false
      # 禁用Eureka的ReadOnlyMap缓存
      use-read-only-response-cache: false
      # eureka server刷新readCacheMap的时间,client读取的是readCacheMap,默认30s
      response-cache-update-interval-ms: 3000
      # 缓存readWriteCacheMap失效时间，因为开启了evict，这个就没起到作用了，默认180s
      response-cache-auto-expiration-in-seconds: 180
      # 服务下线任务定时，默认60s
      eviction-interval-timer-in-ms: 3000
    instance:
      lease-renewal-interval-in-seconds: 5   # 服务刷新时间，默认30s
      lease-expiration-duration-in-seconds: 15   # 超过这个时间没收到心跳就剔除这个服务，这个配置一般为服务刷新时间配置的三倍，默认90s
      health-check-url-path: /actuator/health     #健康检查的地址（依赖spring-boot-starter-actuator）
      hostname: localhost   #eureka服务端的实例名称
    client:
      register-with-eureka: false     #false表示不向注册中心注册自己。
      fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务
      serviceUrl:
        defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/   #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址（单机）。

  management:
    endpoint:
      health:
        show-details: always
    endpoints:
      web:
        exposure:
          include: health,info